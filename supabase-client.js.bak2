/**
 * Supabase Client for VA Manager Pro
 * Complete API functions to replace localStorage operations
 *
 * Features:
 * - Supabase client initialization
 * - User authentication helpers
 * - Password encryption/decryption (AES-GCM)
 * - Complete CRUD operations for all entities
 * - Error handling and logging
 * - Multi-VA creator assignments
 */

// ============================================================================
// INITIALIZATION & CONFIGURATION
// ============================================================================

// Import Supabase client (ensure this is loaded from CDN or npm)
// <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

// Initialize Supabase client
let supabase;

function initSupabase() {
  try {
    if (typeof window.supabase === 'undefined') {
      throw new Error('Supabase library not loaded. Please include the Supabase CDN script.');
    }

    // Check if config is available
    if (typeof SUPABASE_CONFIG === 'undefined') {
      throw new Error('SUPABASE_CONFIG not found. Please include config.js before this script.');
    }

    // Use config from config.js
    supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
    console.log('✅ Supabase client initialized');
    return supabase;
  } catch (error) {
    console.error('❌ Failed to initialize Supabase:', error);
    throw error;
  }
}

// ============================================================================
// ENCRYPTION UTILITIES (Web Crypto API - AES-GCM)
// ============================================================================

// Generate a random encryption key (store this securely!)
// In production, derive this from user's password or store in secure location
const ENCRYPTION_KEY_STORAGE = 'va_manager_encryption_key';

async function getEncryptionKey() {
  try {
    // Try to get existing key from localStorage
    const storedKey = localStorage.getItem(ENCRYPTION_KEY_STORAGE);

    if (storedKey) {
      // Import the stored key
      const keyData = JSON.parse(storedKey);
      return await crypto.subtle.importKey(
        'jwk',
        keyData,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
    }

    // Generate new key if none exists
    const key = await crypto.subtle.generateKey(
      { name: 'AES-GCM', length: 256 },
      true,
      ['encrypt', 'decrypt']
    );

    // Export and store the key
    const exportedKey = await crypto.subtle.exportKey('jwk', key);
    localStorage.setItem(ENCRYPTION_KEY_STORAGE, JSON.stringify(exportedKey));

    return key;
  } catch (error) {
    console.error('❌ Error getting encryption key:', error);
    throw error;
  }
}

/**
 * Encrypt a password using AES-GCM
 * @param {string} password - Plain text password
 * @returns {Promise<string>} - Encrypted password (base64 encoded)
 */
async function encryptPassword(password) {
  try {
    if (!password) return '';

    const key = await getEncryptionKey();
    const iv = crypto.getRandomValues(new Uint8Array(12)); // 96-bit IV for GCM
    const encodedPassword = new TextEncoder().encode(password);

    const encryptedData = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv: iv },
      key,
      encodedPassword
    );

    // Combine IV and encrypted data
    const combined = new Uint8Array(iv.length + encryptedData.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(encryptedData), iv.length);

    // Convert to base64 for storage
    return btoa(String.fromCharCode(...combined));
  } catch (error) {
    console.error('❌ Encryption error:', error);
    throw error;
  }
}

/**
 * Decrypt a password using AES-GCM
 * @param {string} encryptedPassword - Encrypted password (base64 encoded)
 * @returns {Promise<string>} - Plain text password
 */
async function decryptPassword(encryptedPassword) {
  try {
    if (!encryptedPassword) return '';

    const key = await getEncryptionKey();

    // Decode from base64
    const combined = new Uint8Array(
      atob(encryptedPassword).split('').map(c => c.charCodeAt(0))
    );

    // Extract IV and encrypted data
    const iv = combined.slice(0, 12);
    const encryptedData = combined.slice(12);

    const decryptedData = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: iv },
      key,
      encryptedData
    );

    return new TextDecoder().decode(decryptedData);
  } catch (error) {
    console.error('❌ Decryption error:', error);
    // Return empty string if decryption fails (backward compatibility)
    return '';
  }
}

/**
 * Batch encrypt passwords in an object
 * @param {Object} obj - Object with password fields
 * @param {Array<string>} fields - Fields to encrypt (default: ['password'])
 * @returns {Promise<Object>} - Object with encrypted passwords
 */
async function encryptPasswordFields(obj, fields = ['password']) {
  const result = { ...obj };
  for (const field of fields) {
    if (result[field]) {
      result[field] = await encryptPassword(result[field]);
    }
  }
  return result;
}

/**
 * Batch decrypt passwords in an object
 * @param {Object} obj - Object with encrypted password fields
 * @param {Array<string>} fields - Fields to decrypt (default: ['password'])
 * @returns {Promise<Object>} - Object with decrypted passwords
 */
async function decryptPasswordFields(obj, fields = ['password']) {
  const result = { ...obj };
  for (const field of fields) {
    if (result[field]) {
      result[field] = await decryptPassword(result[field]);
    }
  }
  return result;
}

// ============================================================================
// AUTH HELPERS
// ============================================================================

/**
 * Get current authenticated user
 * @returns {Promise<Object|null>} - User object or null
 */
async function getCurrentUser() {
  try {
    const { data: { user }, error } = await supabase.auth.getUser();

    if (error) {
      console.error('❌ Error getting user:', error);
      return null;
    }

    return user;
  } catch (error) {
    console.error('❌ Error getting current user:', error);
    return null;
  }
}

/**
 * Check if user is authenticated
 * @returns {Promise<boolean>}
 */
async function isAuthenticated() {
  const user = await getCurrentUser();
  return user !== null;
}

/**
 * Get current user ID (throws if not authenticated)
 * @returns {Promise<string>}
 */
async function getUserId() {
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }
  return user.id;
}

/**
 * Sign in with email and password
 * @param {string} email
 * @param {string} password
 * @returns {Promise<Object>}
 */
async function signIn(email, password) {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });

    if (error) throw error;

    console.log('✅ User signed in:', data.user.email);
    return { success: true, user: data.user };
  } catch (error) {
    console.error('❌ Sign in error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Sign up with email and password
 * @param {string} email
 * @param {string} password
 * @returns {Promise<Object>}
 */
async function signUp(email, password) {
  try {
    const { data, error } = await supabase.auth.signUp({
      email,
      password
    });

    if (error) throw error;

    console.log('✅ User signed up:', data.user.email);
    return { success: true, user: data.user };
  } catch (error) {
    console.error('❌ Sign up error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Sign out current user
 * @returns {Promise<Object>}
 */
async function signOut() {
  try {
    const { error } = await supabase.auth.signOut();

    if (error) throw error;

    console.log('✅ User signed out');
    return { success: true };
  } catch (error) {
    console.error('❌ Sign out error:', error);
    return { success: false, error: error.message };
  }
}

// ============================================================================
// VAS (Virtual Assistants) - CRUD Operations
// ============================================================================

/**
 * Get all VAs for current user
 * @returns {Promise<Array>}
 */
async function getVAs() {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('vas')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    console.log(`✅ Retrieved ${data.length} VAs`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting VAs:', error);
    throw error;
  }
}

/**
 * Get a single VA by ID
 * @param {string} vaId
 * @returns {Promise<Object|null>}
 */
async function getVA(vaId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('vas')
      .select('*')
      .eq('id', vaId)
      .eq('user_id', userId)
      .single();

    if (error) throw error;

    return data;
  } catch (error) {
    console.error('❌ Error getting VA:', error);
    throw error;
  }
}

/**
 * Create a new VA
 * @param {Object} vaData - { name, ...other fields }
 * @returns {Promise<Object>}
 */
async function createVA(vaData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('vas')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        name: vaData.name,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ VA created:', data.name);
    return data;
  } catch (error) {
    console.error('❌ Error creating VA:', error);
    throw error;
  }
}

/**
 * Update a VA
 * @param {string} vaId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateVA(vaId, updates) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('vas')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', vaId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ VA updated:', vaId);
    return data;
  } catch (error) {
    console.error('❌ Error updating VA:', error);
    throw error;
  }
}

/**
 * Delete a VA (also deletes associated data via CASCADE)
 * @param {string} vaId
 * @returns {Promise<boolean>}
 */
async function deleteVA(vaId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('vas')
      .delete()
      .eq('id', vaId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ VA deleted:', vaId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting VA:', error);
    throw error;
  }
}

// ============================================================================
// CREATORS - CRUD Operations
// ============================================================================

/**
 * Get all creators for current user
 * @returns {Promise<Array>}
 */
async function getCreators() {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('creators')
      .select('*')
      .eq('user_id', userId)
      .order('name', { ascending: true });

    if (error) throw error;

    console.log(`✅ Retrieved ${data.length} creators`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting creators:', error);
    throw error;
  }
}

/**
 * Get creators for a specific VA
 * @param {string} vaId
 * @returns {Promise<Array>}
 */
async function getCreatorsByVA(vaId) {
  try {
    const userId = await getUserId();

    // Get creator IDs from va_creators table
    const { data: vaCreators, error: vcError } = await supabase
      .from('va_creators')
      .select('creator_id')
      .eq('va_id', vaId);

    if (vcError) throw vcError;

    const creatorIds = vaCreators.map(vc => vc.creator_id);

    if (creatorIds.length === 0) return [];

    // Get full creator data
    const { data, error } = await supabase
      .from('creators')
      .select('*')
      .in('id', creatorIds)
      .eq('user_id', userId)
      .order('name', { ascending: true });

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error('❌ Error getting creators by VA:', error);
    throw error;
  }
}

/**
 * Get a single creator by ID
 * @param {string} creatorId
 * @returns {Promise<Object|null>}
 */
async function getCreator(creatorId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('creators')
      .select('*')
      .eq('id', creatorId)
      .eq('user_id', userId)
      .single();

    if (error) throw error;

    return data;
  } catch (error) {
    console.error('❌ Error getting creator:', error);
    throw error;
  }
}

/**
 * Create a new creator
 * @param {Object} creatorData - { name, ...other fields }
 * @returns {Promise<Object>}
 */
async function createCreator(creatorData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('creators')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        name: creatorData.name,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Creator created:', data.name);
    return data;
  } catch (error) {
    console.error('❌ Error creating creator:', error);
    throw error;
  }
}

/**
 * Update a creator
 * @param {string} creatorId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateCreator(creatorId, updates) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('creators')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', creatorId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Creator updated:', creatorId);
    return data;
  } catch (error) {
    console.error('❌ Error updating creator:', error);
    throw error;
  }
}

/**
 * Delete a creator
 * @param {string} creatorId
 * @returns {Promise<boolean>}
 */
async function deleteCreator(creatorId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('creators')
      .delete()
      .eq('id', creatorId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Creator deleted:', creatorId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting creator:', error);
    throw error;
  }
}

// ============================================================================
// VA-CREATOR RELATIONSHIPS
// ============================================================================

/**
 * Assign a creator to a VA
 * @param {string} vaId
 * @param {string} creatorId
 * @returns {Promise<Object>}
 */
async function assignCreatorToVA(vaId, creatorId) {
  try {
    // Check if relationship already exists
    const { data: existing, error: checkError } = await supabase
      .from('va_creators')
      .select('*')
      .eq('va_id', vaId)
      .eq('creator_id', creatorId)
      .maybeSingle();

    if (checkError) throw checkError;

    if (existing) {
      console.log('ℹ️ Creator already assigned to VA');
      return existing;
    }

    const { data, error } = await supabase
      .from('va_creators')
      .insert([{
        va_id: vaId,
        creator_id: creatorId,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Creator assigned to VA');
    return data;
  } catch (error) {
    console.error('❌ Error assigning creator to VA:', error);
    throw error;
  }
}

/**
 * Remove creator from VA
 * @param {string} vaId
 * @param {string} creatorId
 * @returns {Promise<boolean>}
 */
async function removeCreatorFromVA(vaId, creatorId) {
  try {
    const { error } = await supabase
      .from('va_creators')
      .delete()
      .eq('va_id', vaId)
      .eq('creator_id', creatorId);

    if (error) throw error;

    console.log('✅ Creator removed from VA');
    return true;
  } catch (error) {
    console.error('❌ Error removing creator from VA:', error);
    throw error;
  }
}

/**
 * Get all VAs for a creator
 * @param {string} creatorId
 * @returns {Promise<Array>}
 */
async function getVAsForCreator(creatorId) {
  try {
    const userId = await getUserId();

    const { data: vaCreators, error: vcError } = await supabase
      .from('va_creators')
      .select('va_id')
      .eq('creator_id', creatorId);

    if (vcError) throw vcError;

    const vaIds = vaCreators.map(vc => vc.va_id);

    if (vaIds.length === 0) return [];

    const { data, error } = await supabase
      .from('vas')
      .select('*')
      .in('id', vaIds)
      .eq('user_id', userId)
      .order('name', { ascending: true });

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error('❌ Error getting VAs for creator:', error);
    throw error;
  }
}

// ============================================================================
// TWITTER ACCOUNTS - CRUD Operations
// ============================================================================

/**
 * Get all Twitter accounts for current user
 * @returns {Promise<Array>}
 */
async function getTwitterAccounts() {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_accounts')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    console.log(`✅ Retrieved ${decryptedData.length} Twitter accounts`);
    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Twitter accounts:', error);
    throw error;
  }
}

/**
 * Get Twitter accounts for a specific VA
 * @param {string} vaId
 * @returns {Promise<Array>}
 */
async function getTwitterAccountsByVA(vaId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_accounts')
      .select('*')
      .eq('user_id', userId)
      .eq('va_id', vaId)
      .order('username', { ascending: true });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Twitter accounts by VA:', error);
    throw error;
  }
}

/**
 * Get Twitter accounts for a specific creator
 * @param {string} creatorId
 * @returns {Promise<Array>}
 */
async function getTwitterAccountsByCreator(creatorId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_accounts')
      .select('*')
      .eq('user_id', userId)
      .eq('creator_id', creatorId)
      .order('username', { ascending: true });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Twitter accounts by creator:', error);
    throw error;
  }
}

/**
 * Get a single Twitter account by ID
 * @param {string} accountId
 * @returns {Promise<Object|null>}
 */
async function getTwitterAccount(accountId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_accounts')
      .select('*')
      .eq('id', accountId)
      .eq('user_id', userId)
      .single();

    if (error) throw error;

    // Decrypt password
    data.password = await decryptPassword(data.password);

    return data;
  } catch (error) {
    console.error('❌ Error getting Twitter account:', error);
    throw error;
  }
}

/**
 * Create a new Twitter account
 * @param {Object} accountData - { username, password, creator_id, va_id, gmail_id }
 * @returns {Promise<Object>}
 */
async function createTwitterAccount(accountData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    // Encrypt password
    const encryptedPassword = await encryptPassword(accountData.password);

    const { data, error } = await supabase
      .from('twitter_accounts')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        username: accountData.username,
        encrypted_password: encryptedPassword,
        creator_id: accountData.creator_id || null,
        va_id: accountData.va_id || null,
        gmail_id: accountData.gmail_id || null,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Twitter account created:', data.username);

    // Return with decrypted password
    return {
      ...data,
      password: accountData.password
    };
  } catch (error) {
    console.error('❌ Error creating Twitter account:', error);
    throw error;
  }
}

/**
 * Update a Twitter account
 * @param {string} accountId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateTwitterAccount(accountId, updates) {
  try {
    const userId = await getUserId();

    // Encrypt password if provided
    if (updates.password) {
      updates.password = await encryptPassword(updates.password);
    }

    const { data, error } = await supabase
      .from('twitter_accounts')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', accountId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Twitter account updated:', accountId);

    // Decrypt password for return
    data.password = await decryptPassword(data.password);

    return data;
  } catch (error) {
    console.error('❌ Error updating Twitter account:', error);
    throw error;
  }
}

/**
 * Delete a Twitter account
 * @param {string} accountId
 * @returns {Promise<boolean>}
 */
async function deleteTwitterAccount(accountId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('twitter_accounts')
      .delete()
      .eq('id', accountId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Twitter account deleted:', accountId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting Twitter account:', error);
    throw error;
  }
}

// ============================================================================
// INSTAGRAM ACCOUNTS - CRUD Operations
// ============================================================================

/**
 * Get all Instagram accounts for current user
 * @returns {Promise<Array>}
 */
async function getInstagramAccounts() {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('instagram_accounts')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    console.log(`✅ Retrieved ${decryptedData.length} Instagram accounts`);
    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Instagram accounts:', error);
    throw error;
  }
}

/**
 * Get Instagram accounts for a specific creator
 * @param {string} creatorId
 * @returns {Promise<Array>}
 */
async function getInstagramAccountsByCreator(creatorId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('instagram_accounts')
      .select('*')
      .eq('user_id', userId)
      .eq('creator_id', creatorId)
      .order('username', { ascending: true });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Instagram accounts by creator:', error);
    throw error;
  }
}

/**
 * Create a new Instagram account
 * @param {Object} accountData - { username, password, creator_id, va_id, gmail_id }
 * @returns {Promise<Object>}
 */
async function createInstagramAccount(accountData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    // Encrypt password
    const encryptedPassword = await encryptPassword(accountData.password);

    const { data, error } = await supabase
      .from('instagram_accounts')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        username: accountData.username,
        encrypted_password: encryptedPassword,
        creator_id: accountData.creator_id || null,
        va_id: accountData.va_id || null,
        gmail_id: accountData.gmail_id || null,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Instagram account created:', data.username);

    return {
      ...data,
      password: accountData.password
    };
  } catch (error) {
    console.error('❌ Error creating Instagram account:', error);
    throw error;
  }
}

/**
 * Update an Instagram account
 * @param {string} accountId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateInstagramAccount(accountId, updates) {
  try {
    const userId = await getUserId();

    // Encrypt password if provided
    if (updates.password) {
      updates.password = await encryptPassword(updates.password);
    }

    const { data, error } = await supabase
      .from('instagram_accounts')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', accountId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Instagram account updated:', accountId);

    data.password = await decryptPassword(data.password);

    return data;
  } catch (error) {
    console.error('❌ Error updating Instagram account:', error);
    throw error;
  }
}

/**
 * Delete an Instagram account
 * @param {string} accountId
 * @returns {Promise<boolean>}
 */
async function deleteInstagramAccount(accountId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('instagram_accounts')
      .delete()
      .eq('id', accountId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Instagram account deleted:', accountId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting Instagram account:', error);
    throw error;
  }
}

// ============================================================================
// GMAIL ACCOUNTS - CRUD Operations
// ============================================================================

/**
 * Get all Gmail accounts for current user
 * @returns {Promise<Array>}
 */
async function getGmailAccounts() {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('gmail_accounts')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    console.log(`✅ Retrieved ${decryptedData.length} Gmail accounts`);
    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Gmail accounts:', error);
    throw error;
  }
}

/**
 * Get Gmail accounts for a specific VA
 * @param {string} vaId
 * @returns {Promise<Array>}
 */
async function getGmailAccountsByVA(vaId) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('gmail_accounts')
      .select('*')
      .eq('user_id', userId)
      .eq('va_id', vaId)
      .order('email', { ascending: true });

    if (error) throw error;

    // Decrypt passwords
    const decryptedData = await Promise.all(
      (data || []).map(async account => ({
        ...account,
        password: await decryptPassword(account.password)
      }))
    );

    return decryptedData;
  } catch (error) {
    console.error('❌ Error getting Gmail accounts by VA:', error);
    throw error;
  }
}

/**
 * Create a new Gmail account
 * @param {Object} accountData - { email, password, va_id, notes }
 * @returns {Promise<Object>}
 */
async function createGmailAccount(accountData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    // Encrypt password
    const encryptedPassword = await encryptPassword(accountData.password);

    const { data, error } = await supabase
      .from('gmail_accounts')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        email: accountData.email,
        encrypted_password: encryptedPassword,
        va_id: accountData.va_id || null,
        notes: accountData.notes || '',
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Gmail account created:', data.email);

    return {
      ...data,
      password: accountData.password
    };
  } catch (error) {
    console.error('❌ Error creating Gmail account:', error);
    throw error;
  }
}

/**
 * Update a Gmail account
 * @param {string} accountId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateGmailAccount(accountId, updates) {
  try {
    const userId = await getUserId();

    // Encrypt password if provided
    if (updates.password) {
      updates.password = await encryptPassword(updates.password);
    }

    const { data, error } = await supabase
      .from('gmail_accounts')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', accountId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Gmail account updated:', accountId);

    data.password = await decryptPassword(data.password);

    return data;
  } catch (error) {
    console.error('❌ Error updating Gmail account:', error);
    throw error;
  }
}

/**
 * Delete a Gmail account
 * @param {string} accountId
 * @returns {Promise<boolean>}
 */
async function deleteGmailAccount(accountId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('gmail_accounts')
      .delete()
      .eq('id', accountId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Gmail account deleted:', accountId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting Gmail account:', error);
    throw error;
  }
}

// ============================================================================
// SUBSCRIPTIONS - CRUD Operations
// ============================================================================

/**
 * Get all subscriptions for current user
 * @returns {Promise<Array>}
 */
async function getSubscriptions() {
  try {
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('subscriptions')
      .select('*')
      .eq('organization_id', organizationId)
      .order('date', { ascending: false });

    if (error) throw error;

    console.log(`✅ Retrieved ${data.length} subscriptions`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting subscriptions:', error);
    throw error;
  }
}

/**
 * Get subscriptions for a specific VA
 * @param {string} vaId
 * @returns {Promise<Array>}
 */
async function getSubscriptionsByVA(vaId) {
  try {
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('subscriptions')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('va_id', vaId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error('❌ Error getting subscriptions by VA:', error);
    throw error;
  }
}

/**
 * Create a new subscription entry
 * @param {Object} subData - { va_id, date, count, amount }
 * @returns {Promise<Object>}
 */
async function createSubscription(subData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('subscriptions')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        va_id: subData.va_id,
        date: subData.date,
        count: subData.count,
        amount: subData.amount || (subData.count * 0.50), // Default $0.50 per sub
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Subscription created:', data.id);
    return data;
  } catch (error) {
    console.error('❌ Error creating subscription:', error);
    throw error;
  }
}

/**
 * Update a subscription
 * @param {string} subId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateSubscription(subId, updates) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('subscriptions')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', subId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Subscription updated:', subId);
    return data;
  } catch (error) {
    console.error('❌ Error updating subscription:', error);
    throw error;
  }
}

/**
 * Delete a subscription
 * @param {string} subId
 * @returns {Promise<boolean>}
 */
async function deleteSubscription(subId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('subscriptions')
      .delete()
      .eq('id', subId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Subscription deleted:', subId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting subscription:', error);
    throw error;
  }
}

// ============================================================================
// REVENUES - CRUD Operations
// ============================================================================

/**
 * Get all revenues for current user
 * @returns {Promise<Array>}
 */
async function getRevenues() {
  try {
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('revenues')
      .select('*')
      .eq('organization_id', organizationId)
      .order('date', { ascending: false });

    if (error) throw error;

    console.log(`✅ Retrieved ${data.length} revenues`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting revenues:', error);
    throw error;
  }
}

/**
 * Get revenues for a specific VA
 * @param {string} vaId
 * @returns {Promise<Array>}
 */
async function getRevenuesByVA(vaId) {
  try {
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('revenues')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('va_id', vaId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error('❌ Error getting revenues by VA:', error);
    throw error;
  }
}

/**
 * Create a new revenue entry
 * @param {Object} revenueData - { va_id, date, amount_usd, amount_eur, exchange_rate, tracking_link, description, commission }
 * @returns {Promise<Object>}
 */
async function createRevenue(revenueData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('revenues')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        va_id: revenueData.va_id,
        date: revenueData.date,
        amount_usd: revenueData.amount_usd,
        amount_eur: revenueData.amount_eur,
        exchange_rate: revenueData.exchange_rate,
        tracking_link: revenueData.tracking_link || '',
        description: revenueData.description || '',
        commission: revenueData.commission || 0,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Revenue created:', data.id);
    return data;
  } catch (error) {
    console.error('❌ Error creating revenue:', error);
    throw error;
  }
}

/**
 * Update a revenue
 * @param {string} revenueId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateRevenue(revenueId, updates) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('revenues')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', revenueId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Revenue updated:', revenueId);
    return data;
  } catch (error) {
    console.error('❌ Error updating revenue:', error);
    throw error;
  }
}

/**
 * Delete a revenue
 * @param {string} revenueId
 * @returns {Promise<boolean>}
 */
async function deleteRevenue(revenueId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('revenues')
      .delete()
      .eq('id', revenueId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Revenue deleted:', revenueId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting revenue:', error);
    throw error;
  }
}

// ============================================================================
// PAYMENTS (VA Payments) - CRUD Operations
// ============================================================================

/**
 * Get all payments for current user
 * @returns {Promise<Array>}
 */
async function getPayments() {
  try {
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('payments')
      .select('*')
      .eq('organization_id', organizationId)
      .order('date', { ascending: false });

    if (error) throw error;

    console.log(`✅ Retrieved ${data.length} payments`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting payments:', error);
    throw error;
  }
}

/**
 * Get payments for a specific VA
 * @param {string} vaId
 * @returns {Promise<Array>}
 */
async function getPaymentsByVA(vaId) {
  try {
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('payments')
      .select('*')
      .eq('organization_id', organizationId)
      .eq('va_id', vaId)
      .order('date', { ascending: false });

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error('❌ Error getting payments by VA:', error);
    throw error;
  }
}

/**
 * Create a new payment entry
 * @param {Object} paymentData - { va_id, date, amount, description }
 * @returns {Promise<Object>}
 */
async function createPayment(paymentData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('payments')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        va_id: paymentData.va_id,
        date: paymentData.date,
        amount: paymentData.amount,
        description: paymentData.description || '',
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Payment created:', data.id);
    return data;
  } catch (error) {
    console.error('❌ Error creating payment:', error);
    throw error;
  }
}

/**
 * Update a payment
 * @param {string} paymentId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updatePayment(paymentId, updates) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('payments')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', paymentId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Payment updated:', paymentId);
    return data;
  } catch (error) {
    console.error('❌ Error updating payment:', error);
    throw error;
  }
}

/**
 * Delete a payment
 * @param {string} paymentId
 * @returns {Promise<boolean>}
 */
async function deletePayment(paymentId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('payments')
      .delete()
      .eq('id', paymentId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Payment deleted:', paymentId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting payment:', error);
    throw error;
  }
}

// ============================================================================
// TWITTER STATS - CRUD Operations
// ============================================================================

/**
 * Get all Twitter stats for current user
 * @returns {Promise<Array>}
 */
async function getTwitterStats() {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_stats')
      .select('*')
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (error) throw error;

    console.log(`✅ Retrieved ${data.length} Twitter stats`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting Twitter stats:', error);
    throw error;
  }
}

/**
 * Get Twitter stats for a specific account
 * @param {string} username
 * @returns {Promise<Array>}
 */
async function getTwitterStatsByUsername(username) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_stats')
      .select('*')
      .eq('user_id', userId)
      .eq('username', username)
      .order('date', { ascending: false });

    if (error) throw error;

    return data || [];
  } catch (error) {
    console.error('❌ Error getting Twitter stats by username:', error);
    throw error;
  }
}

/**
 * Get latest Twitter stats for an account
 * @param {string} username
 * @returns {Promise<Object|null>}
 */
async function getLatestTwitterStat(username) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_stats')
      .select('*')
      .eq('user_id', userId)
      .eq('username', username)
      .order('date', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (error) throw error;

    return data;
  } catch (error) {
    console.error('❌ Error getting latest Twitter stat:', error);
    throw error;
  }
}

/**
 * Create a new Twitter stats entry
 * @param {Object} statsData - { username, date, followers_count, va_id, creator_id }
 * @returns {Promise<Object>}
 */
async function createTwitterStat(statsData) {
  try {
    const userId = await getUserId();
    const organizationId = await getOrganizationId();

    const { data, error } = await supabase
      .from('twitter_stats')
      .insert([{
        user_id: userId,
        organization_id: organizationId,
        username: statsData.username,
        date: statsData.date,
        followers_count: statsData.followers_count,
        va_id: statsData.va_id || null,
        creator_id: statsData.creator_id || null,
        created_at: new Date().toISOString()
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Twitter stat created:', data.username, data.followers_count);
    return data;
  } catch (error) {
    console.error('❌ Error creating Twitter stat:', error);
    throw error;
  }
}

/**
 * Update a Twitter stat
 * @param {string} statId
 * @param {Object} updates
 * @returns {Promise<Object>}
 */
async function updateTwitterStat(statId, updates) {
  try {
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('twitter_stats')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('id', statId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Twitter stat updated:', statId);
    return data;
  } catch (error) {
    console.error('❌ Error updating Twitter stat:', error);
    throw error;
  }
}

/**
 * Delete a Twitter stat
 * @param {string} statId
 * @returns {Promise<boolean>}
 */
async function deleteTwitterStat(statId) {
  try {
    const userId = await getUserId();

    const { error } = await supabase
      .from('twitter_stats')
      .delete()
      .eq('id', statId)
      .eq('user_id', userId);

    if (error) throw error;

    console.log('✅ Twitter stat deleted:', statId);
    return true;
  } catch (error) {
    console.error('❌ Error deleting Twitter stat:', error);
    throw error;
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Get complete VA data with all associated records
 * @param {string} vaId
 * @returns {Promise<Object>}
 */
async function getCompleteVAData(vaId) {
  try {
    const [
      va,
      creators,
      twitterAccounts,
      gmailAccounts,
      subscriptions,
      revenues,
      payments
    ] = await Promise.all([
      getVA(vaId),
      getCreatorsByVA(vaId),
      getTwitterAccountsByVA(vaId),
      getGmailAccountsByVA(vaId),
      getSubscriptionsByVA(vaId),
      getRevenuesByVA(vaId),
      getPaymentsByVA(vaId)
    ]);

    return {
      va,
      creators,
      twitterAccounts,
      gmailAccounts,
      subscriptions,
      revenues,
      payments
    };
  } catch (error) {
    console.error('❌ Error getting complete VA data:', error);
    throw error;
  }
}

/**
 * Get complete creator data with all accounts
 * @param {string} creatorId
 * @returns {Promise<Object>}
 */
async function getCompleteCreatorData(creatorId) {
  try {
    const [
      creator,
      vas,
      twitterAccounts,
      instagramAccounts
    ] = await Promise.all([
      getCreator(creatorId),
      getVAsForCreator(creatorId),
      getTwitterAccountsByCreator(creatorId),
      getInstagramAccountsByCreator(creatorId)
    ]);

    return {
      creator,
      vas,
      twitterAccounts,
      instagramAccounts
    };
  } catch (error) {
    console.error('❌ Error getting complete creator data:', error);
    throw error;
  }
}

/**
 * Get all data for current user (for migration/export)
 * @returns {Promise<Object>}
 */
async function getAllUserData() {
  try {
    const [
      vas,
      creators,
      twitterAccounts,
      instagramAccounts,
      gmailAccounts,
      subscriptions,
      revenues,
      payments,
      twitterStats
    ] = await Promise.all([
      getVAs(),
      getCreators(),
      getTwitterAccounts(),
      getInstagramAccounts(),
      getGmailAccounts(),
      getSubscriptions(),
      getRevenues(),
      getPayments(),
      getTwitterStats()
    ]);

    // Get VA-Creator relationships
    const vaCreatorRelations = [];
    for (const creator of creators) {
      const creatorVAs = await getVAsForCreator(creator.id);
      for (const va of creatorVAs) {
        vaCreatorRelations.push({
          va_id: va.id,
          creator_id: creator.id
        });
      }
    }

    console.log('✅ Retrieved all user data');

    return {
      vas,
      creators,
      vaCreatorRelations,
      twitterAccounts,
      instagramAccounts,
      gmailAccounts,
      subscriptions,
      revenues,
      payments,
      twitterStats
    };
  } catch (error) {
    console.error('❌ Error getting all user data:', error);
    throw error;
  }
}

/**
 * Bulk insert data (for migration from localStorage)
 * @param {Object} data - Complete data object
 * @returns {Promise<Object>} - Summary of inserted records
 */
async function bulkInsertData(data) {
  try {
    const userId = await getUserId();
    const summary = {
      vas: 0,
      creators: 0,
      twitterAccounts: 0,
      instagramAccounts: 0,
      gmailAccounts: 0,
      subscriptions: 0,
      revenues: 0,
      payments: 0,
      twitterStats: 0
    };

    // Insert VAs
    if (data.vas && data.vas.length > 0) {
      const vasData = data.vas.map(va => ({
        user_id: userId,
        name: va.name,
        created_at: va.created || new Date().toISOString()
      }));

      const { data: insertedVAs, error } = await supabase
        .from('vas')
        .insert(vasData)
        .select();

      if (error) throw error;
      summary.vas = insertedVAs.length;
    }

    // Insert Creators
    if (data.creators && data.creators.length > 0) {
      const creatorsData = data.creators.map(creator => ({
        user_id: userId,
        name: creator.name,
        created_at: creator.created || new Date().toISOString()
      }));

      const { data: insertedCreators, error } = await supabase
        .from('creators')
        .insert(creatorsData)
        .select();

      if (error) throw error;
      summary.creators = insertedCreators.length;

      // Insert VA-Creator relationships
      if (data.vaCreatorRelations) {
        for (const relation of data.vaCreatorRelations) {
          await assignCreatorToVA(relation.va_id, relation.creator_id);
        }
      }
    }

    // Insert Twitter accounts (with encrypted passwords)
    if (data.twitterAccounts && data.twitterAccounts.length > 0) {
      for (const account of data.twitterAccounts) {
        await createTwitterAccount(account);
        summary.twitterAccounts++;
      }
    }

    // Insert Instagram accounts
    if (data.instagramAccounts && data.instagramAccounts.length > 0) {
      for (const account of data.instagramAccounts) {
        await createInstagramAccount(account);
        summary.instagramAccounts++;
      }
    }

    // Insert Gmail accounts
    if (data.gmailAccounts && data.gmailAccounts.length > 0) {
      for (const account of data.gmailAccounts) {
        await createGmailAccount(account);
        summary.gmailAccounts++;
      }
    }

    // Insert Subscriptions
    if (data.subs && data.subs.length > 0) {
      const subsData = data.subs.map(sub => ({
        user_id: userId,
        va_id: sub.vaId,
        date: sub.date,
        count: sub.count,
        amount: sub.amount,
        created_at: sub.created || new Date().toISOString()
      }));

      const { data: insertedSubs, error } = await supabase
        .from('subscriptions')
        .insert(subsData)
        .select();

      if (error) throw error;
      summary.subscriptions = insertedSubs.length;
    }

    // Insert Revenues
    if (data.revenues && data.revenues.length > 0) {
      const revenuesData = data.revenues.map(rev => ({
        user_id: userId,
        va_id: rev.vaId,
        date: rev.date,
        amount_usd: rev.amountUSD,
        amount_eur: rev.amountEUR,
        exchange_rate: rev.exchangeRate,
        tracking_link: rev.trackingLink || '',
        description: rev.description || '',
        commission: rev.commission || 0,
        created_at: rev.created || new Date().toISOString()
      }));

      const { data: insertedRevenues, error } = await supabase
        .from('revenues')
        .insert(revenuesData)
        .select();

      if (error) throw error;
      summary.revenues = insertedRevenues.length;
    }

    // Insert Payments
    if (data.vaPayments && data.vaPayments.length > 0) {
      const paymentsData = data.vaPayments.map(payment => ({
        user_id: userId,
        va_id: payment.vaId,
        date: payment.date,
        amount: payment.amount,
        description: payment.description || '',
        created_at: payment.created || new Date().toISOString()
      }));

      const { data: insertedPayments, error } = await supabase
        .from('payments')
        .insert(paymentsData)
        .select();

      if (error) throw error;
      summary.payments = insertedPayments.length;
    }

    // Insert Twitter Stats
    if (data.twitterStats && data.twitterStats.length > 0) {
      const statsData = data.twitterStats.map(stat => ({
        user_id: userId,
        username: stat.username,
        date: stat.date,
        followers_count: stat.followersCount || stat.followers_count,
        va_id: stat.vaId || null,
        creator_id: stat.creatorId || null,
        created_at: stat.created || new Date().toISOString()
      }));

      const { data: insertedStats, error } = await supabase
        .from('twitter_stats')
        .insert(statsData)
        .select();

      if (error) throw error;
      summary.twitterStats = insertedStats.length;
    }

    console.log('✅ Bulk insert completed:', summary);
    return summary;

  } catch (error) {
    console.error('❌ Error during bulk insert:', error);
    throw error;
  }
}

/**
 * Check database health
 * @returns {Promise<Object>}
 */
async function checkDatabaseHealth() {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return {
        status: 'error',
        message: 'User not authenticated'
      };
    }

    const data = await getAllUserData();

    return {
      status: 'healthy',
      user: user.email,
      counts: {
        vas: data.vas.length,
        creators: data.creators.length,
        twitterAccounts: data.twitterAccounts.length,
        instagramAccounts: data.instagramAccounts.length,
        gmailAccounts: data.gmailAccounts.length,
        subscriptions: data.subscriptions.length,
        revenues: data.revenues.length,
        payments: data.payments.length,
        twitterStats: data.twitterStats.length
      }
    };
  } catch (error) {
    return {
      status: 'error',
      message: error.message
    };
  }
}

// ============================================================================
// ORGANIZATION/TEAM MANAGEMENT
// ============================================================================

/**
 * Get user's organization
 * @returns {Promise<Object|null>}
 */
async function getUserOrganization() {
  try {
    const userId = await getUserId();

    // D'abord, chercher si l'user est propriétaire d'une org
    let { data, error } = await supabase
      .from('organizations')
      .select('*')
      .eq('owner_id', userId)
      .maybeSingle();

    if (error) throw error;

    // Si trouvé, retourner
    if (data) return data;

    // Sinon, chercher s'il est membre d'une org
    const { data: membership, error: memberError } = await supabase
      .from('organization_members')
      .select('organization_id')
      .eq('user_id', userId)
      .maybeSingle();

    if (memberError) throw memberError;

    if (!membership) return null;

    // Récupérer l'organisation via le membership
    const { data: org, error: orgError } = await supabase
      .from('organizations')
      .select('*')
      .eq('id', membership.organization_id)
      .single();

    if (orgError) throw orgError;

    return org;
  } catch (error) {
    console.error('❌ Error getting user organization:', error);
    throw error;
  }
}

/**
 * Get organization ID
 * @returns {Promise<string>}
 */
async function getOrganizationId() {
  const org = await getUserOrganization();
  return org?.id;
}

/**
 * Get organization members
 * @returns {Promise<Array>}
 */
async function getOrganizationMembers() {
  try {
    const orgId = await getOrganizationId();

    // Get members without auth.users join (not allowed via REST API)
    const { data, error } = await supabase
      .from('organization_members')
      .select('*')
      .eq('organization_id', orgId);

    if (error) throw error;

    console.log(`✅ Retrieved ${data?.length || 0} organization members`);
    return data || [];
  } catch (error) {
    console.error('❌ Error getting organization members:', error);
    // Return empty array instead of throwing to avoid blocking the page
    return [];
  }
}

/**
 * Invite member to organization (create invitation link/code)
 * @param {string} email - Email of invitee
 * @param {string} role - Role for the new member
 * @returns {Promise<Object>}
 */
async function inviteMemberToOrganization(email, role = 'member') {
  try {
    const orgId = await getOrganizationId();
    // For now, just return an invitation code
    return {
      invitationCode: `${orgId}:${role}`,
      organizationId: orgId,
      role: role
    };
  } catch (error) {
    console.error('❌ Error creating invitation:', error);
    throw error;
  }
}

/**
 * Accept invitation (add user to organization)
 * @param {string} invitationCode - Invitation code
 * @returns {Promise<Object>}
 */
async function acceptInvitation(invitationCode) {
  try {
    const [orgId, role] = invitationCode.split(':');
    const userId = await getUserId();

    const { data, error } = await supabase
      .from('organization_members')
      .insert([{
        organization_id: orgId,
        user_id: userId,
        role: role || 'member'
      }])
      .select()
      .single();

    if (error) throw error;

    console.log('✅ User joined organization');
    return data;
  } catch (error) {
    console.error('❌ Error accepting invitation:', error);
    throw error;
  }
}

/**
 * Remove member from organization
 * @param {string} memberId - Member ID to remove
 * @returns {Promise<boolean>}
 */
async function removeMemberFromOrganization(memberId) {
  try {
    const { error } = await supabase
      .from('organization_members')
      .delete()
      .eq('id', memberId);

    if (error) throw error;

    console.log('✅ Member removed from organization');
    return true;
  } catch (error) {
    console.error('❌ Error removing member:', error);
    throw error;
  }
}

/**
 * Update organization name
 * @param {Object} updates - Updates to apply
 * @returns {Promise<Object>}
 */
async function updateOrganization(updates) {
  try {
    const orgId = await getOrganizationId();
    const { data, error } = await supabase
      .from('organizations')
      .update(updates)
      .eq('id', orgId)
      .select()
      .single();

    if (error) throw error;

    console.log('✅ Organization updated');
    return data;
  } catch (error) {
    console.error('❌ Error updating organization:', error);
    throw error;
  }
}

// ============================================================================
// EXPORTS
// ============================================================================

// Export all functions
if (typeof module !== 'undefined' && module.exports) {
  // Node.js/CommonJS
  module.exports = {
    // Initialization
    initSupabase,
    supabase,

    // Encryption
    encryptPassword,
    decryptPassword,
    encryptPasswordFields,
    decryptPasswordFields,

    // Auth
    getCurrentUser,
    isAuthenticated,
    getUserId,
    signIn,
    signUp,
    signOut,

    // VAs
    getVAs,
    getVA,
    createVA,
    updateVA,
    deleteVA,

    // Creators
    getCreators,
    getCreatorsByVA,
    getCreator,
    createCreator,
    updateCreator,
    deleteCreator,

    // VA-Creator Relationships
    assignCreatorToVA,
    removeCreatorFromVA,
    getVAsForCreator,

    // Twitter Accounts
    getTwitterAccounts,
    getTwitterAccountsByVA,
    getTwitterAccountsByCreator,
    getTwitterAccount,
    createTwitterAccount,
    updateTwitterAccount,
    deleteTwitterAccount,

    // Instagram Accounts
    getInstagramAccounts,
    getInstagramAccountsByCreator,
    createInstagramAccount,
    updateInstagramAccount,
    deleteInstagramAccount,

    // Gmail Accounts
    getGmailAccounts,
    getGmailAccountsByVA,
    createGmailAccount,
    updateGmailAccount,
    deleteGmailAccount,

    // Subscriptions
    getSubscriptions,
    getSubscriptionsByVA,
    createSubscription,
    updateSubscription,
    deleteSubscription,

    // Revenues
    getRevenues,
    getRevenuesByVA,
    createRevenue,
    updateRevenue,
    deleteRevenue,

    // Payments
    getPayments,
    getPaymentsByVA,
    createPayment,
    updatePayment,
    deletePayment,

    // Twitter Stats
    getTwitterStats,
    getTwitterStatsByUsername,
    getLatestTwitterStat,
    createTwitterStat,
    updateTwitterStat,
    deleteTwitterStat,

    // Organizations/Team
    getUserOrganization,
    getOrganizationId,
    getOrganizationMembers,
    inviteMemberToOrganization,
    acceptInvitation,
    removeMemberFromOrganization,
    updateOrganization,

    // Utilities
    getCompleteVAData,
    getCompleteCreatorData,
    getAllUserData,
    bulkInsertData,
    checkDatabaseHealth
  };
} else {
  // Browser/Window
  window.SupabaseClient = {
    // Initialization
    initSupabase,

    // Encryption
    encryptPassword,
    decryptPassword,
    encryptPasswordFields,
    decryptPasswordFields,

    // Auth
    getCurrentUser,
    isAuthenticated,
    getUserId,
    signIn,
    signUp,
    signOut,

    // VAs
    getVAs,
    getVA,
    createVA,
    updateVA,
    deleteVA,

    // Creators
    getCreators,
    getCreatorsByVA,
    getCreator,
    createCreator,
    updateCreator,
    deleteCreator,

    // VA-Creator Relationships
    assignCreatorToVA,
    removeCreatorFromVA,
    getVAsForCreator,

    // Twitter Accounts
    getTwitterAccounts,
    getTwitterAccountsByVA,
    getTwitterAccountsByCreator,
    getTwitterAccount,
    createTwitterAccount,
    updateTwitterAccount,
    deleteTwitterAccount,

    // Instagram Accounts
    getInstagramAccounts,
    getInstagramAccountsByCreator,
    createInstagramAccount,
    updateInstagramAccount,
    deleteInstagramAccount,

    // Gmail Accounts
    getGmailAccounts,
    getGmailAccountsByVA,
    createGmailAccount,
    updateGmailAccount,
    deleteGmailAccount,

    // Subscriptions
    getSubscriptions,
    getSubscriptionsByVA,
    createSubscription,
    updateSubscription,
    deleteSubscription,

    // Revenues
    getRevenues,
    getRevenuesByVA,
    createRevenue,
    updateRevenue,
    deleteRevenue,

    // Payments
    getPayments,
    getPaymentsByVA,
    createPayment,
    updatePayment,
    deletePayment,

    // Twitter Stats
    getTwitterStats,
    getTwitterStatsByUsername,
    getLatestTwitterStat,
    createTwitterStat,
    updateTwitterStat,
    deleteTwitterStat,

    // Organizations/Team
    getUserOrganization,
    getOrganizationId,
    getOrganizationMembers,
    inviteMemberToOrganization,
    acceptInvitation,
    removeMemberFromOrganization,
    updateOrganization,

    // Utilities
    getCompleteVAData,
    getCompleteCreatorData,
    getAllUserData,
    bulkInsertData,
    checkDatabaseHealth
  };
}
